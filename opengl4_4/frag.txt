#version 330
uniform mat4 viewMatrix, projMatrix;

in vec4 Color;
in vec4 Position;
in vec3 Normal;
out vec4 outputF;

//the following source of information proved to be quite useful
//		http://cs.nyu.edu/~elif/phong.pdf

//will also use this for the lighting
//		http://www.ics.uci.edu/~gopi/CS211A/classes/illumination.pdf
 
void main()
{	
    
	//using 4 entries for color to allow alpha channel
	//	this will let us implement transparency
	//outputF = vec4(Color,0.1);
	outputF = Color;

	vec3 lightColor = vec3(1,1,1);
	vec3 lightCoordinates = vec3(2,0,-5);
	vec3 cameraCoordinates = vec3(0,0,-10);
	float specularPower = 3;

	vec3 lightVector = lightCoordinates - vec3(Position);
	float lightDistance = length(lightVector);
	lightVector = normalize(lightVector);

	//get the attentuation
	//	A = 1/(a + b*r + c*r^2)
	float attenuation_a = 0.02;
	float attenuation_b = 0.01;
	float attenuation_c = 0.03;
	float attenuation_denominator = attenuation_a + attenuation_b*lightDistance + attenuation_c*lightDistance*lightDistance;
	float attenuation = 1/attenuation_denominator;

	//reflection vector is calculated as follows:
	//		R = L - 2(N.L)N 
	//	    where R is reflection vector, N is normal vector normalized, and L is light vector normalized

	//gets the specular component
	vec3 eyeVector = cameraCoordinates - vec3(Position);
	eyeVector = normalize(eyeVector);
	vec3 normalVector = normalize(Normal);
	vec3 reflectionVector = lightVector - 2 * dot(normalVector,lightVector) * normalVector;
	float specularPart = pow(dot(reflectionVector,eyeVector),specularPower);
	float specular = max(0,specularPart);

	vec3 specularLight = lightColor*specular*attenuation;
	vec3 outputColor = min(Color.xyz + specularLight, vec3(1.0));

	outputF = vec4(outputColor,Color.w);

}